package zhy2002.jaxb.impl;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.convert.ConversionService;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;
import zhy2002.jaxb.JAXBElementDefaultValueResolver;

import javax.annotation.PostConstruct;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.HashSet;
import java.util.Set;

/**
 * Set default values for a JAXB DTO based on the annotations generated by JAXB.
 * This resolver will only set default values for objects whose class is under inspectedPackage or listed in inspectedClasses.
 */
public class ClassNameDefaultValueResolver implements JAXBElementDefaultValueResolver {

    private Logger logger = LoggerFactory.getLogger(ClassNameDefaultValueResolver.class);

    /**
     * Resolve default values for the object graph.
     * @param jaxbObject an jaxb object.
     */
    public void resolve(Object jaxbObject) {
        applySchemaDefaultValues(jaxbObject, new HashSet<Integer>());
    }

    /**
     * Construct an instance.
     *
     * @param conversionService Spring conversion service used to convert string to the default value type.
     */
    public ClassNameDefaultValueResolver(ConversionService conversionService) {
        if (conversionService == null)
            throw new IllegalArgumentException("conversionService cannot be null.");
        this.conversionService = conversionService;
    }

    private ConversionService conversionService;

    private String inspectedPackage;

    private Set<String> inspectedClasses;

    private Set<String> excludedClasses;

    /**
     * Check configuration.
     */
    @PostConstruct
    public void init() {
        if (StringUtils.isEmpty(inspectedPackage) && (inspectedClasses == null || inspectedClasses.size() == 0)) {
            logger.warn("At least one of inspectedPackage or inspectedClasses should be configured.");
        }
    }

    /**
     * Get the inspected package name.
     * Instances of classes under this package will be processes.
     *
     * @return the inspected package name.
     */
    public String getInspectedPackage() {
        return inspectedPackage;
    }

    /**
     * Set the inspected package name.
     *
     * @param inspectedPackage can be null if there is none.
     */
    public void setInspectedPackage(String inspectedPackage) {
        this.inspectedPackage = inspectedPackage;
    }

    /**
     * Get a set of fully qualified class names whose instances should be processed.
     *
     * @return set of class names. Do not modify this set as this could cause concurrency issue.
     */
    public Set<String> getInspectedClasses() {
        return inspectedClasses;
    }

    /**
     * Inject the inspected class names.
     *
     * @param inspectedClasses a set of inspected class names.
     */
    public void setInspectedClasses(Set<String> inspectedClasses) {
        if (inspectedClasses == null)
            this.inspectedClasses = null;
        else
            this.inspectedClasses = new HashSet<>(inspectedClasses);//in case not passing in a hash set.
    }

    /**
     * Get the list of excluded class names.
     * @return excluded class names. Exclusion takes precedence to inclusion. Do not modify this set as this could cause concurrency issue.
     */
    public Set<String> getExcludedClasses() {
        return excludedClasses;
    }

    /**
     * Inject the excluded class names.
     *
     * @param excludedClasses excluded class names.
     */
    public void setExcludedClasses(Set<String> excludedClasses) {
        if (excludedClasses == null) {
            this.excludedClasses = null;
        } else {
            this.excludedClasses = new HashSet<>(excludedClasses);
        }
    }

    /**
     * Recursively set schema default values for the given JAXB dto. Declared public for unit testing.
     *
     * @param object  JAXB dto.
     * @param visited This set contains identityHashCode of the visited objects.
     * @return true if the object is inspected false otherwise.
     */
    protected boolean applySchemaDefaultValues(Object object, Set<Integer> visited) {

        if (object == null)
            return false;

        Class<?> clazz = object.getClass(); //bypass all system classes
        if (isClassIgnored(clazz))
            return false;

        Integer objectId = System.identityHashCode(object);
        if (visited.contains(objectId))
            return false;

        visited.add(objectId);
        if (object instanceof Iterable) { //handle list/set
            for (Object child : (Iterable) object) {
                if (child != null && !applySchemaDefaultValues(child, visited))
                    return false;
            }
            return true;
        }

        //check properties
        Method[] methods = clazz.getMethods();
        for (Method method : methods) {

            String methodName = getGetterName(method);//public instance getter
            if (methodName == null)
                continue;

            //get field to check XmlElement annotation
            String fieldName = getFieldName(methodName);
            Field field = ReflectionUtils.findField(clazz, fieldName);
            if (field == null)
                continue;

            //get default value
            String defaultValue = "\u0000";
            XmlElement elementAnnotation = field.getAnnotation(XmlElement.class);
            if (elementAnnotation == null) {
                if (field.getAnnotation(XmlAttribute.class) != null)
                    continue;
            } else if (!"\u0000".equals(elementAnnotation.defaultValue())) {
                defaultValue = elementAnnotation.defaultValue();
            }

            //get current value
            Object value;
            try {
                value = method.invoke(object);
            } catch (IllegalAccessException | IllegalArgumentException |  InvocationTargetException ex) {
                logger.warn("JAXBElementDefaultValueResolver failed to get field value: " + ex.getMessage());
                continue;
            }

            if (value == null) {
                if (!"\u0000".equals(defaultValue)) //set default value
                    setDefaultValue(object, method, defaultValue);
            } else { //inspect
                applySchemaDefaultValues(value, visited);
            }
        }
        return true;
    }

    /**
     * Set default value of a property.
     *
     * @param target       the target object.
     * @param getter       the getter of the property.
     * @param defaultValue the value in string format.
     */
    private void setDefaultValue(Object target, Method getter, String defaultValue) {

        if (!conversionService.canConvert(String.class, getter.getReturnType()))
            return;
        Object convertedValue = conversionService.convert(defaultValue, getter.getReturnType());

        //find setter name
        String methodName = getSetterName(getter.getName());
        try {
            Method setter = target.getClass().getMethod(methodName, getter.getReturnType());
            if (Modifier.isStatic(setter.getModifiers()) || !Modifier.isPublic(setter.getModifiers()))
                return; //not public instance setter

            setter.invoke(target, convertedValue);
        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException ex) {
            logger.warn("JAXBElementDefaultValueResolver failed to set field default value:" + ex.getMessage());
            //ignore
        }
    }


    /**
     * Check if an instance of the given class can be inspected.
     *
     * @param clazz object class.
     * @return true if cannot inspect.
     */
    private boolean isClassIgnored(Class<?> clazz) {

        if (clazz.isPrimitive())
            return true;

        if (Iterable.class.isAssignableFrom(clazz))
            return false;

        if(excludedClasses != null && excludedClasses.contains(clazz.getName()))
            return true;

        if (inspectedClasses != null && inspectedClasses.contains(clazz.getName()))
            return false;

        return inspectedPackage == null || !clazz.getPackage().getName().startsWith(inspectedPackage);
    }

    /**
     * Check if the given method is a getter. If so return its name. Otherwise return null.
     *
     * @param method the method to check.
     * @return null if method is not getter.
     */
    private static String getGetterName(Method method) {
        if (!Modifier.isPublic(method.getModifiers()) || Modifier.isStatic(method.getModifiers()))
            return null;

        //is getter
        String methodName = method.getName();
        if (methodName.startsWith("get")) {
            if (method.getName().equals("getClass") || method.getName().equals("getBytes"))
                return null;
        } else if (methodName.startsWith("is")) {
            if (!Boolean.class.isAssignableFrom(method.getReturnType())) {
                return null;
            }

        } else {
            return null;
        }
        if (method.getParameterTypes().length != 0)
            return null;
        return methodName;
    }

    /**
     * Get the corresponding setter name from the getter name.
     *
     * @param methodName name of the getter.
     * @return setter name.
     */
    private static String getSetterName(String methodName) {

        if (methodName.startsWith("get"))
            methodName = methodName.substring(3, methodName.length());
        else
            methodName = methodName.substring(2, methodName.length());
        methodName = "set" + methodName;
        return methodName;
    }

    /**
     * Get the field name from the getter name.
     *
     * @param methodName getter method name.
     * @return field name by Java bean convention.
     */
    private static String getFieldName(String methodName) {
        String fieldName;
        if (methodName.startsWith("get"))
            fieldName = methodName.substring(3, methodName.length());
        else
            fieldName = methodName.substring(2, methodName.length());
        fieldName = fieldName.substring(0, 1).toLowerCase() + fieldName.substring(1);
        if("default".equals(fieldName))
            return "_default";
        return fieldName;
    }
}
